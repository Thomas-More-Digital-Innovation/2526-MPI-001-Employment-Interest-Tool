name: Deploy Test Production Environment

on:
  push:
    branches:
      - 'prod-test-env'
  workflow_dispatch:
    
concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: false
    
jobs:
  build-and-transfer:
    name: Build docker image and transfer to remote server
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v5
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    # Build the application Docker image
    - name: Build custom App Docker image
      working-directory: code
      run: |
        docker buildx build --platform linux/amd64 -t mpi-employment-interest-tool:latest --output type=tar,dest=mpi-employment-interest-tool.tar .

    # Build the custom Nginx Docker image
    - name: Build custom Nginx Docker image
      working-directory: code
      run: |
        docker buildx build --platform linux/amd64 -f Dockerfile.nginx -t custom-nginx:latest --output type=tar,dest=custom-nginx.tar .

    - name: Save SSH private key
      run: |
        echo "${{ secrets.SSH_PRIVATE_KEY_VALUE }}" > ${{ secrets.SSH_PRIVATE_KEY_FILENAME }}
        chmod 600 ${{ secrets.SSH_PRIVATE_KEY_FILENAME }}

    - name: Install cloudflared
      run: |
        curl -L https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -o cloudflared
        chmod +x cloudflared
        sudo mv cloudflared /usr/local/bin/

    - name: Transfer Docker images to VM
      run: |
        scp -o StrictHostKeyChecking=no \
            -o ProxyCommand="cloudflared access ssh --hostname %h --service-token-id ${{ secrets.SERVICE_TOKEN_ID }} --service-token-secret ${{ secrets.SERVICE_TOKEN_SECRET }}" \
            -i ${{ secrets.SSH_PRIVATE_KEY_FILENAME }} \
            code/mpi-employment-interest-tool.tar \
            code/custom-nginx.tar \
            ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }}:~/
    
    # Copy the .env.test.prod file to the vm and copy it to .env and .env.test.prod
    - name: Copy .env.test.prod to VM and setup environment
      run: |
        scp -o StrictHostKeyChecking=no \
            -o ProxyCommand="cloudflared access ssh --hostname %h --service-token-id ${{ secrets.SERVICE_TOKEN_ID }} --service-token-secret ${{ secrets.SERVICE_TOKEN_SECRET }}" \
            -i ${{ secrets.SSH_PRIVATE_KEY_FILENAME }} \
            code/.env.test.prod \
            ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }}:~/.env.test.prod
        ssh -o StrictHostKeyChecking=no \
            -o ProxyCommand="cloudflared access ssh --hostname %h --service-token-id ${{ secrets.SERVICE_TOKEN_ID }} --service-token-secret ${{ secrets.SERVICE_TOKEN_SECRET }}" \
            -i ${{ secrets.SSH_PRIVATE_KEY_FILENAME }} \
            ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} \
            "if [ -f /etc/laravel/app_key ]; then cat /etc/laravel/app_key >> .env.test.prod; else echo 'ERROR: /etc/laravel/app_key not found on server' >&2; exit 2; fi && \
            if [ -f /etc/laravel/mail ]; then cat /etc/laravel/mail >> .env.test.prod; else echo 'ERROR: /etc/laravel/mail not found on server' >&2; exit 2; fi && \
            cp .env.test.prod .env"

    # Import the images on the vm
    - name: Import Docker images on VM
      run: |
        ssh -o StrictHostKeyChecking=no \
            -o ProxyCommand="cloudflared access ssh --hostname %h --service-token-id ${{ secrets.SERVICE_TOKEN_ID }} --service-token-secret ${{ secrets.SERVICE_TOKEN_SECRET }}" \
            -i ${{ secrets.SSH_PRIVATE_KEY_FILENAME }} \
            ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} \
            "docker import \
              --change 'ENTRYPOINT [\"/usr/local/bin/php-entrypoint\"]' \
              --change 'CMD [\"php-fpm\"]' \
              --change 'EXPOSE 9000' \
              --change 'WORKDIR /usr/share/nginx/html/' \
              ~/mpi-employment-interest-tool.tar mpi-employment-interest-tool:latest && \
            docker import \
              --change 'CMD [\"nginx\", \"-g\", \"daemon off;\"]' \
              --change 'EXPOSE 443' \
              ~/custom-nginx.tar custom-nginx:latest"
    
    # Stop the compose on the vm
    - name: Stop Docker Compose on VM
      run: |
        ssh -o StrictHostKeyChecking=no \
            -o ProxyCommand="cloudflared access ssh --hostname %h --service-token-id ${{ secrets.SERVICE_TOKEN_ID }} --service-token-secret ${{ secrets.SERVICE_TOKEN_SECRET }}" \
            -i ${{ secrets.SSH_PRIVATE_KEY_FILENAME }} \
            ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} \
            "docker compose down"
    
     # Copy the compose.test.prod.yml to the vm
    - name: Copy Docker Compose file to VM
      run: |
        scp -o StrictHostKeyChecking=no \
            -o ProxyCommand="cloudflared access ssh --hostname %h --service-token-id ${{ secrets.SERVICE_TOKEN_ID }} --service-token-secret ${{ secrets.SERVICE_TOKEN_SECRET }}" \
            -i ${{ secrets.SSH_PRIVATE_KEY_FILENAME }} \
            code/compose.test.prod.yml \
            ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }}:~/compose.yml
    
    # Start the compose on the vm
    - name: Start Docker Compose on VM
      run: |
        ssh -o StrictHostKeyChecking=no \
            -o ProxyCommand="cloudflared access ssh --hostname %h --service-token-id ${{ secrets.SERVICE_TOKEN_ID }} --service-token-secret ${{ secrets.SERVICE_TOKEN_SECRET }}" \
            -i ${{ secrets.SSH_PRIVATE_KEY_FILENAME }} \
            ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} \
            "docker compose up -d"
    
    # Clean up docker images on the vm
    - name: Clean up Docker images on VM
      run: |
        ssh -o StrictHostKeyChecking=no \
            -o ProxyCommand="cloudflared access ssh --hostname %h --service-token-id ${{ secrets.SERVICE_TOKEN_ID }} --service-token-secret ${{ secrets.SERVICE_TOKEN_SECRET }}" \
            -i ${{ secrets.SSH_PRIVATE_KEY_FILENAME }} \
            ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} \
            "docker image prune -f"
